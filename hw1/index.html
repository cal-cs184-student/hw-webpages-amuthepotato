<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names: Meghna Subramanium, </div>

		<br>

		Link to webpage: (TODO) <a href="https://cal-cs184-student.github.io/hw-webpages-amuthepotato/hw1/index.html">cs184.eecs.berkeley.edu/sp25</a>
		
		<br>

		Link to GitHub repository: (TODO) <a href="https://github.com/cal-cs184-student/hw-webpages-amuthepotato">cs184.eecs.berkeley.edu/sp25</a>

		<figure>
			<img src="lion.jpg" alt="Lion" style="width:50%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		In this project, we implemented a lot of different graphics processes, including triangle rasterization, supersampling for antialiasing, transformations, and texture mapping with filtering techniques to reduce aliasing artifacts.
		Our program takes in an image and then converts it into pixels for display on a screen. Since triangles are the foundation for a lot of modern graphics, we implemented algoritmhs to determine whether a sample point was inside a triangle and then interpolated values such 
		as color or texture coordinates across the surface. Supersampling was used to improve image quality so that a lot of jagged edges would appear smoother. Transformations were another key feature. By using transformation matrices, objects could now be
		scaled, translated, and rotated to become new images. Texture mapping was used to extend the renderer beyond flat colors. We used interpolation of texture coordinates and experimented with pixel sampling methods and level sampling techniques to reduce aliasing.
		Overall, this assignment brought together concepts from linear algebra and computer graphics into a cohesive system. One of the most interesting takeaways was realizing how many subtle details are required to make rendering look “correct.” Features that seem simple, like smooth edges or textures, require careful mathematical reasoning and algorithm design. Implementing the pipeline from scratch gave us a much deeper appreciation for these complexities are abstracted while performing the same core operations at a massive scale.

		<h2>Task 1: Drawing Single-Color Triangles</h2>
		Triangle rasterization is the process of converting a triangle defined in 2D space into a set of discrete piels on a screen. It determines which pixels in the framebuffer should be colored in to visually represent that triangle. To rasterize the triangle, we first ensured that the vertices are consistently ordered (counterclockwise)
		by computing the signed area using a cross product and swapping the two vertices if the orientation was clockwise (if the area was less than 0). Then, to compute the bounding box of the triangle (the smallest rectangle that fully contains the triangle), we took the minimum and maximum x and y values of the three vertices and used 
		floor and ceil to make sure no pixels were cut off. Then, for each pixel in the bounding box, we iterated over every pixel with a double for loop and used an edge function to test if the pixel was on the correct side of the edge of the triangle (inside or not). If it passed all the three edge tests, that means it's inside the triangle
		and then we can write color to the corresponding position in the sample buffer. Our algorithm is no worse than one that checks each sample within the bounding box of the triangle because it does exactly that. We restricted all the work to be inside the bounding box and performed a constant amount of computation per sample. 

		<figure>
			<img src="Task 1 Picture.png" alt="Task 1 Picture" style="width:50%"/>
			<figcaption>Test 4 with the default viewing parameters and showing the edge of the triangle.</figcaption>
		</figure>

		<!--<p>Here is an example 2x2 gridlike structure using an HTML table. Each <b>tr</b> is a row and each <b>td</b> is a column in that row. You might find this useful for framing and showing your result images in an organized fashion.</p> -->
		<!-- <div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			</table>
		</div> -->
		
		<h2>Task 2: Antialiasing by Supersampling</h2>
		<p>When rasterizing geometric objects, such as triangles, the resolution of the grid is not always sufficient for fine details. This limitation causes aliasing, as discussed in lecture, as seen in the jagged edges above from Task 1. Supersampling is an anti-aliasning technique that takes multiple subsamples within each pixel instead of just sampling the pixel center. The final pixel color is an average of each subpixel colors. This approach creates smoother edges, especially at sharp corners or thin edges, as seen in the images below. </p>
		<p>In our rasterizer, each pixel has multiple subpixel samples stored in <b>sample_buffer</b>, with the number of samples determined by the <b>sample_rate</b>. For triangles, I loop over each pixel in the triangle’s bounding box and check each subpixel for coverage using a line test. Subpixels that are inside the triangle are assigned the triangle’s color, and later the pixel’s final color is computed by averaging all subpixel samples inside it. This avergaing step is done inside <b>resolve_to_framebuffer</b>. To avoide averaging out poitns and lines, I filled all subpixels with the same color in <b>fill_pixel</b>. </p>
		<p>The effect of supersampling can be seen below. Partially covered pixels contribute proportionally to the final color, which eliminates the jagged edges that appear at low sample rates. The effect is very noticeable at small angles or the tips of narrow triangles, where aliasing is most pronounced. By averaging multiple subpixel samples, the rasterizer effectively simulates a higher resolution image before downsampling to the display resolution. At a sample rate of 1, aliasing is visible and jagged edges are seen at the narrow tip of the triangle. However, at a sample rate of 16, the triangle edges appear more smooth because the high number of subpixel samples captures finer details and blends the colors more.</p>

		<div style="display: flex; flex-direction: column; align-items: center;">
		<table style="width: 100%; text-align: center; border-collapse: collapse;">
			<tr>
			<td style="text-align: center;">
				<img src="task2_samp1.png" width="400px"/>
				<figcaption>Sample rate = 1.</figcaption>
			</td>
			<td style="text-align: center;">
				<img src="task2_samp4.png" width="400px"/>
				<figcaption>Sample rate =4.</figcaption>
			</td>
			<td style="text-align: center;">
				<img src="task2_samp16.png" width="400px"/>
				<figcaption>Sample rate = 16.</figcaption>
			</td>
			</tr>
		</table>
		</div>

		<h2>Task 3: Transforms</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Task 4: Barycentric coordinates</h2>
		<p> I like to think of barycentric coordinates in the linear algebra interpretation. Barycentric coordinates treat a triangle’s vertices as a basis and express any point inside a triangle as a linear combination of the vertices. Each point has three coefficients, &alpha, &beta, and &gamma, corresponding to the weight of each basis vertex. This is seen in the image below. </p>
		<figure>
			<img src="task3_bary.png" alt="Lion" style="width:50%"/>
			<figcaption>Barycentric coordinates in the linear algebra interpretation.</figcaption>
		</figure>
		<p> Barycentric coordinates are used for linear interpolation In our rasterizer, I used barycentric coordinates to interpolate colors. For a triangle with vertices colored red, blue, and green, the color at any point inside the triangle can be calculated as &alpha c0 + &beta c1 + &gamma c2, where c0, c1, and c2 are the vertex colors. This example is seen below, as well as a screenshot of basic/test7.svg. </p>
		<div style="display: flex; flex-direction: column; align-items: center;">
		<table style="width: 100%; text-align: center; border-collapse: collapse;">
			<tr>
			<td style="text-align: center;">
				<img src="task3_tri.png" width="400px"/>
				<figcaption>Linear interpolation with color on simple triangle.</figcaption>
			</td>
			<td style="text-align: center;">
				<img src="task3_circle.png" width="400px"/>
				<figcaption>Test case passed! :D</figcaption>
			</td>
			</tr>
		</table>
		</div>

		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>(Optional) Task 7: Extra Credit - Draw Something Creative!</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>